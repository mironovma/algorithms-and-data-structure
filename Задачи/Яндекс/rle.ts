/**
 * Дана строка (возможно, пустая), состоящая из букв A-Z:
 * AAAABBBCCXYZDDDDEEEFFFAAAAA
 * Нужно написать функцияю RLE, которая на выходе даст строку вида:
 * A4B3C2XYZD4E3F3A5 и сгенерирует ошибку, если на вход пришла невалидная строка.
 *
 * Пояснение: если символ встречается 1 раз, он остается без изменений,
 * если символ повторяется более 1 раза, то к нему добавляется кол-во повторений.
 */

/**
 * Упростим задачу.
 * На вход ждем такую же строку и просто ее сокращаем до вида:
 * ABCXYZDEFA
 */

const rleEasy = (str: string) => {
  /**
   * Записываем первый символ в переменную (предыдущий символ)
   */
  let lastSymbol = str[0];
  /**
   * Инициализируем массив, который потом сджоиним, для ответа
   */
  let ans: string[] = [];

  for (let i = 0; i < str.length; i++) {
    /**
     * Если следующий символ в цикле не равен предыдущему, то
     */
    if (str[i] != lastSymbol) {
      /**
       * Добавляем последний, который положили в lastSymbol, в массив
       */
      ans.push(lastSymbol);
      /**
       * И теперь сохраняем в lastSymbol новый уникальный попавшийся символ
       */
      lastSymbol = str[i];
    }
  }
  /**
   * В конце не забываем, что нужно добавить в массив то, что хранится в lasySymbol
   */
  ans.push(lastSymbol);

  return ans.join("");
};

// ABCSXYA
console.log(rleEasy("AAAABBBBCCSXYAA"));

/**
 * Решение полной задачи
 *
 * Нужно теперь не просто положить символ, который был в lasySymbol, а еще написать число:
 * сколько раз он встречался.
 *
 * Для этого нужно знать, где началась эта последовательность повторяющихся символов.
 * Т.е. запоминать позицию, с которой идет предыдущий символ и каждый раз, когда
 * встретился новый символ, эту позицию обновлять.
 *
 * А потом, зная текущую позицию и запомненную, где встречался предыдущий символ, мы легко
 * посчитаем длину.
 */

const rle = (str: string) => {
  /**
   * Создаем функцию упаковки
   */
  function pack(str: string, count: number) {
    /**
     * Если символ встречался более 1 раза, то добавляем к этому символу число
     * (сколько раз повторяется этот символ)
     * Напр., А2
     */
    if (count > 1) {
      return str + count;
    }
    /**
     * Иначе просто вернем один этот символ: А
     */
    return str;
  }

  /**
   * Снова записываем первый символ в переменную
   */
  let lastSymbol = str[0];
  /**
   * И записываем его позицию
   */
  let lastPosition = 0;
  /**
   * Результат, который потом сджоиним, для ответа
   */
  let ans: string[] = [];

  /**
   * Идем по всей строке
   */
  for (let i = 0; i < str.length; i++) {
    /**
     * Если следующий символ в цикле не равен предыдущему, то
     */
    if (str[i] !== lastSymbol) {
      /**
       * Если текущий символ не равен предыдущему, то
       * упаковываем последний символ, текущая позиция минус где начался этот последний символ.
       *
       * Напр.:
       * AAB
       *
       * Первый А - lastPosition (0), доходим до В (2) (т.е. до отличной буквы), то
       * вычитаем из текущего индекса i - lastPosition (2 - 0), т.е. понимаем, что здесь
       * 2 одинаковые буквы, то упаковываем lastSymbol столько то раз (2).
       *
       * В этом случае функция pack (см. выше) вернет A2
       */
      ans.push(pack(lastSymbol, i - lastPosition));
      /**
       * Меняем теперь lastPosition на новую текущую итерацию
       */
      lastPosition = i;
      /**
       * И, соответственно, меняем последний символ на новый
       */
      lastSymbol = str[i];
    }
  }
  /**
   * В конце не забываем, что нужно добавить в массив то, что хранится в lasySymbol.
   * Это может быть один символ:
   * АААВВВС
   * и тогда мы запушим символ С, который будет у нас повторяться длинаСтроки - последняя позиция (7 - 6 = 1),
   * т.к. по функции pack мы не попадаем в if, т.к. count не будет больше 1, то просто запушим С.
   *
   * Если будет АААВВВСС, то запушим С2
   */
  ans.push(pack(str[lastPosition], str.length - lastPosition));
  /**
   * Возвращаем сам ответ
   */
  return ans.join("");
};

console.log(rle("AAABCCD")); // A3BC2D
