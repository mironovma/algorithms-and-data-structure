let count = 0;

const selectionSort = (arr: number[]) => {
  /**
   * Создаем внешний цикл и проходимся по всему массиву
   */
  for (let i = 0; i < arr.length; i++) {
    /**
     * Инициализируем минимальное значение текущим индексом на текущей итерации
     */
    let min = i;

    /**
     * Вторым циклом проходимся по массиву, чтобы найти наименьший элемент в оставшейся части массива,
     * т.е. уже проходимся по массиву не с самого начала, а на текущей итерации внешнего цикла + 1.
     */
    for (let j = i + 1; j < arr.length; j++) {
      count += 1;
      /**
       * Если элемент внутреннего цикла меньше элемента внешнего (на текущей итерации),
       * то меняем индекс минимального значения на индекс элемента внутреннего цикла.
       */
      if (arr[j] < arr[min]) {
        min = j;
      }
    }
    /**
     * Если найденный наименьший индекс элемента не равен текущему (внешнего цикла),
     * то меняем их местами
     */
    if (min !== i) {
      /**
       * Создаем временную переменную с элементом внешнего цикла, чтобы не потерять его
       */
      const temp = arr[i];
      /**
       * А тут просто меняем элементы местами. arr[i] меняем на наименьший arr[min],
       * а на место arr[min] ставим элемент, который был на arr[i] (т.е. temp).
       */
      arr[i] = arr[min];
      arr[min] = temp;
    }
  }
  /**
   * Возвращаем отсортированный массив.
   */
  return arr;
};

const sorted = selectionSort([3, 1, 4, 1, 5, 9, 2, 6, 3, 3, 5, 11, -1, 0, -6]);

console.log(
  `Массив [${sorted}], состоящий из ${sorted.length} элементов, отсортирован за ${count} итераций.`
);

// O(1/2 * n*n), но, т.к. коэфф-ты отбрасываются, то сложность будет O(n^2)
