/**
 * Дано число x. Нужно вернуть true, если число является
 * палиндромом (т.е. число будет таким же при чтении слева направо и справа налево).
 *
 * Input: x = 121
 * Output: true
 * Explanation: 121 reads as 121 from left to right and from right to left
 *
 * Input: x = -121
 * Output: false
 * Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
 *
 * Follow up*: Решить без конвертирования числа в строку.
 */

/**
 * Простой вариант с преобразованием в строку
 */
const isPalindromeSimple = function (x: number) {
  return +String(x).split("").reverse().join("") === x;
};

const isPalindrome = (x: number) => {
  /**
   * Сразу выполняем проверку на отрицательные числа.
   * Любые отрицательные числа не будут являться палиндромом.
   * -121 !== 121-
   *
   * Кроме этого, числа, оканчивающиеся на 0 тоже не будут палиндромами.
   */
  if (x < 0 || x % 10 === 0) {
    return false;
  }
  /**
   * Создаем переменную под реверснутое число
   */
  let reversed = 0;
  /**
   * Сохраняем изначальное число
   */
  let original = x;

  /**
   * Запускаем while до тех пор, пока original больше reversed.
   * Остановимся на цикле, когда original станет меньше reversed.
   * Если число является палиндромом, то быть больше original быть не может.
   */
  while (original > reversed) {
    /**
     * Умножаем reversed на 10 и прибавляем остаток от деления original.
     * Т.е. здесь мы "сдвигаем цифры" reversed на одну позицию влево и
     * добавляем последнюю цифру из original в конец.
     */
    reversed = reversed * 10 + (original % 10);
    /**
     * Затем изменяем original, разделив его на 10 и округляем.
     * Это позволяет удалить последнюю цифру из original, т.к.
     * мы уже использовали ее в reversed.
     */
    original = Math.floor(original / 10);
    /**
     * Приведу подробный расчет:
     * 1 итерация цикла:
     * rev = 0 * 10 + 121 % 10 = 0 + 1 = 1;
     * ori = 121 / 10 = 12;
     * 2 итерация цикла:
     * rev = 1 * 10 + 12 % 10 = 10 + 2 = 12;
     * ori = 12 / 10 = 1;
     * и т.д.
     */
  }
  /**
   * Таким образом, на каждой итерации цикла мы берем последнюю
   * цифру из original и добавляем ее в конец reversed, путем
   * умножения reversed на 10 и прибавления остатка от деления original на 10.
   *
   * Затем мы удаляем эту последнюю цифру из original.
   * Повторяя этот процесс до тех пор, пока original не станет равным 0,
   * мы получаем перевернутое число reversed.
   *
   * Далее просто сравниваем перевернутое число с исходным x.
   *
   * Второе условие ИЛИ проверяет тот случай, когда исходное число x имеет нечетное количество цифр.
   * В процессе переворачивания числа, мы удаляем последнюю цифру из original и добавляем
   * ее в конец reversed. Когда число original станет меньше или равным reversed, это означает, что мы перевернули половину числа.
   *
   * Напр., если x = 12321:
   * 1 итерация цикла:
   * original = 1232, reversed = 1;
   * 2 итерация цикла:
   * original = 123, reversed = 12;
   * 3итерация цикла:
   * original = 12, reversed = 123;
   *
   * Мы перевернули первую половину числа, но осталась середина (цифра 3) в original.
   * Если длина числа x нечетная, то средняя цифра остается на своем месте и
   * не имеет значения для проверки палиндромности.
   * Поэтому мы можем исключить эту среднюю цифру из reversed
   * с помощью операции Math.floor(reversed / 10).
   *
   * Таким образом условия x === Math.floor(reversed / 10) проверяет, равни ли x и reversed
   * (для чисел с нечетным кол-вом цифр), и возвращает true, если число является палиндромом.
   *
   * Если бы такого условия не было, то числа с нечетным кол-ом цифр не было бы распознано как палиндром.
   */

  return x === reversed || x === Math.floor(reversed / 10);
};

console.log(isPalindrome(121));
console.log(isPalindrome(12321));
console.log(isPalindrome(120));
console.log(isPalindrome(-120));
